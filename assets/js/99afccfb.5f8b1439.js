"use strict";(self.webpackChunkbeethoven_docs=self.webpackChunkbeethoven_docs||[]).push([[2822],{6216:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"type":"mdx","permalink":"/Beethoven-Docs/Beethoven/Platform/NewPlatform","source":"@site/src/pages/Beethoven/Platform/NewPlatform.md","title":"Platform Integration","description":"In order to add a new platform to Beethoven, you must essentially implement a shim between the Beethoven layer","frontMatter":{},"unlisted":false}');var i=t(4848),s=t(8453);const r={},a="Platform Integration",l={},c=[{value:"Front Bus",id:"front-bus",level:2},{value:"Diplomacy Node Exposure",id:"diplomacy-node-exposure",level:3},{value:"Host Commands",id:"host-commands",level:4},{value:"Host DMA",id:"host-dma",level:4},{value:"Top-Level IO Exposure",id:"top-level-io-exposure",level:3},{value:"Platform Parameters",id:"platform-parameters",level:3},{value:"Alternative Usage Patterns",id:"alternative-usage-patterns",level:3},{value:"Memory",id:"memory",level:2},{value:"Floorplanning",id:"floorplanning",level:2},{value:"Platform Fine-Tuning",id:"platform-fine-tuning",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"platform-integration",children:"Platform Integration"})}),"\n",(0,i.jsxs)(n.p,{children:["In order to add a new platform to Beethoven, you must essentially implement a shim between the Beethoven layer\nand the device. The full ",(0,i.jsx)(n.code,{children:"Platform"})," interface is defined ",(0,i.jsx)(n.a,{href:"https://github.com/Composer-Team/Composer-Hardware/blob/master/src/main/scala/beethoven/Platforms/Platform.scala",children:"here"}),"\nand is intended to provide a comprehensive backbone for Beethoven to generate interconnects and floorplans.\nWe will go through the entire interface below."]}),"\n",(0,i.jsx)(n.h2,{id:"front-bus",children:"Front Bus"}),"\n",(0,i.jsxs)(n.p,{children:["The front bus is intended to receive commands from the host over some sort of ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O",children:"memory-mapped IO"})," (MMIO)\nand service responses requests. Because of the breadth of ways this communication may be exposed, we leave it quite open ended and define a ",(0,i.jsx)(n.code,{children:"FrontBusProtocol"})," as an interface\nthat"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Defines Diplomacy nodes for delivering RoCC commands"}),"\n",(0,i.jsx)(n.li,{children:"Defines top-level IOs"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Accordingly, ",(0,i.jsx)(n.code,{children:"FrontBusProtocol"})," is define as:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"abstract class FrontBusProtocol {\n    def deriveTLSources(implicit p:Parameters) : Config\n    def deriveTopIOs(tlChainObj: Any, withClock: Clock, withActiveHighReset: Reset)(implicit p: Parameters): Unit\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"diplomacy-node-exposure",children:"Diplomacy Node Exposure"}),"\n",(0,i.jsxs)(n.p,{children:["As an example of how we implement a protocol using this interface, we look to our ",(0,i.jsx)(n.code,{children:"AXIFrontBusProtocol"})," ",(0,i.jsx)(n.a,{href:"https://github.com/Composer-Team/Composer-Hardware/blob/master/src/main/scala/beethoven/Protocol/FrontBus/AXIFrontBusProtocol.scala",children:"implementation"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'class AXIFrontBusProtocol(withDMA: Boolean) extends FrontBusProtocol {\n    ...\n    override def deriveTLSources(implicit p: Parameters): Config = {\n        // which floorplanning object (e.g., die) contains the front bus interfaces\n        // this allows us to place any hardware attached to these interfaces close to the interfaces\n        val frontInterfaceID = platform.physicalInterfaces.find(_.isInstanceOf[PhysicalHostInterface]).get.locationDeviceID\n\n        \n        // We\'re going to expose an AXI4 interface to the device so we need to declare it here\n        DeviceContext.withDevice(frontInterfaceID) {\n        val axi_master = AXI4MasterNode(Seq(AXI4MasterPortParameters(\n            masters = Seq(AXI4MasterParameters(\n            name = "S00_AXI",\n            aligned = true,\n            maxFlight = Some(1),\n            id = IdRange(0, 1 << 16)\n            )),\n        )))\n        // instantiate the front-hub module which converts AXI4 MMIOs into RoCC commands\n        val fronthub =\n            DeviceContext.withDevice(frontInterfaceID) {\n                val fronthub = LazyModuleWithFloorplan(new FrontBusHub(), "zzfront6_axifronthub")\n                fronthub.axi_in := axi_master\n                fronthub\n            }\n\n        // if there is a DMA port from the host, we can instnatate that\n        val (dma_node, dma_front) = if (withDMA) {\n            val node = AXI4MasterNode(Seq(AXI4MasterPortParameters(\n                masters = Seq(AXI4MasterParameters(\n                name = "S01_AXI",\n                maxFlight = Some(1),\n                aligned = true,\n                id = IdRange(0, 1 << 6)\n                ))\n            )))\n            // convert it to TileLink\n            val dma2tl = TLIdentityNode()\n            DeviceContext.withDevice(frontInterfaceID) {\n                dma2tl :=\n                    make_tl_buffer() :=\n                    LazyModuleWithFloorplan(new LongAXI4ToTL(64)).node :=\n                    AXI4UserYanker(capMaxFlight = Some(1)) :=\n                    AXI4IdIndexer(1) :=\n                    AXI4Buffer() := node\n            }\n            (Some(node), Some(dma2tl))\n        } else (None, None)\n\n        // finally, expose the RoCC interface to Beethoven\n        val rocc_xb = DeviceContext.withDevice(frontInterfaceID) { RoccFanout("zzfront_7roccout") }\n        rocc_xb := fronthub.rocc_out\n\n        // We return the following 3 keys to Beethoven\n        // OptionalPassKey lets us pass arbitrary objects to ourselves when we expose the Top-level IOs \n        //      Since we declared the AXI diplomacy nodes for the host and dma, we\'ll need to connect them\n        //      to the IOs when we construct them\n        new Config((_, _, _) => {\n            case OptionalPassKey => (axi_master, dma_node)\n            case RoccNodeKey => rocc_xb\n            case DMANodeKey => dma_front\n            // debug only\n            case DebugCacheProtSignalKey => fronthub.module.io.cache_prot\n        })\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"There's quite a bit going on here but we can break it down into two categories."}),"\n",(0,i.jsx)(n.h4,{id:"host-commands",children:"Host Commands"}),"\n",(0,i.jsxs)(n.p,{children:["We declare a diplomacy node that corresponds to the communication channel that we're\ngoing to connect to the host: ",(0,i.jsx)(n.code,{children:"axi_master"}),". Because this front-end is intended to facilitate MMIO between\nus and the host, we have to implement that functionality. For this reason, we instantiate a ",(0,i.jsx)(n.code,{children:"FrontBusHub"}),",\nwhich implements this MMIO slave port. From this hub, it produces a RoCC diplomacy node, ",(0,i.jsx)(n.code,{children:"rocc_out"}),". Below\nthe DMA instantation, you see we connect this node to a RoCC crossbar node to add a buffer between the hub\nand Beethoven. Finally, we pass crossbar node to Beethoven by placing it in a Config object under the\n",(0,i.jsx)(n.code,{children:"RoccNodeKey"})," key."]}),"\n",(0,i.jsxs)(n.p,{children:["But how are we going to connect ",(0,i.jsx)(n.code,{children:"axi_master"})," to the top-level IOs? Notice that we haven't actually instantiated\nthem yet. We will do that next in the second ",(0,i.jsx)(n.code,{children:"FrontBusProtocol"})," function. To pass ",(0,i.jsx)(n.code,{children:"axi_master"})," to our function\nthat we'll define in the future, we put it inside an object under the ",(0,i.jsx)(n.code,{children:"OptionalPassKey"})," key in our Config."]}),"\n",(0,i.jsx)(n.h4,{id:"host-dma",children:"Host DMA"}),"\n",(0,i.jsxs)(n.p,{children:["In case the device supports DMA from host, we can add an additional AXI port for servicing these reads and writes\nthat are functionally different from the MMIOs we receive on our ",(0,i.jsx)(n.code,{children:"axi_master"})," port.\nThis time, instead of connecting it to a ",(0,i.jsx)(n.code,{children:"FrontBusHub"}),", we'll convert it to the TileLink protocol, which Beethoven\nuses internally for elaborating the memory interconnect. From this construction we, like before, obtain two objects:\na diplomacy node that corresponds to our top-level DMA IOs (AXI4) and a diplomacy node that corresponds to the\nTileLink node that will issue memory transactions into our memory interconnect."]}),"\n",(0,i.jsxs)(n.p,{children:["Like with host commands, we need to pass the diplomacy node coresponding to our top-level IOs to ourselves for later\nuse so we put that, as well, into the ",(0,i.jsx)(n.code,{children:"OptionalPassKey"})," key. Next, for exposing the TileLink node we pass it to\nBeethoven under the ",(0,i.jsx)(n.code,{children:"DMANodeKey"})," key as an optional type. If you are not using DMA, then simply pass ",(0,i.jsx)(n.code,{children:"None"})," to this\nfield."]}),"\n",(0,i.jsx)(n.h3,{id:"top-level-io-exposure",children:"Top-Level IO Exposure"}),"\n",(0,i.jsxs)(n.p,{children:["To tie the aformentioned diplomacy nodes to top-level IOs, we implement the ",(0,i.jsx)(n.code,{children:"deriveTopIOs"})," function for ",(0,i.jsx)(n.code,{children:"FrontBusProtocol"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"def deriveTopIOs(tlChainObj: Any, withClock: Clock, withActiveHighReset: Reset)(implicit p: Parameters): Unit\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tlChainObj: Any"}),": This is the object that you created and passed to ",(0,i.jsx)(n.code,{children:"OptionalPassKey"}),". As you can see, this is an\n",(0,i.jsx)(n.code,{children:"Any"})," type, giving you freedom to pass arbitrary objects/information between these functions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"withClock: Clock"}),", ",(0,i.jsx)(n.code,{children:"withActiveHighReset: Reset"}),": In case you need to instantiate any ",(0,i.jsx)(n.code,{children:"Module"})," types, you would do\nit in this function and use these clocks and resets. Be wary of the active-high reset signal."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here is how we use this function to connect our diplomacy nodes to the AXI nodes in Beethoven."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"override def deriveTopIOs(tlChainObj: Any, withClock: Clock, withActiveHighReset: Reset)(implicit p: Parameters): Unit = {\n    val (port_cast, dma_cast) = tlChainObj.asInstanceOf[(AXI4MasterNode, Option[AXI4MasterNode])]\n    val ap = port_cast.out(0)._1.params\n    // instantiate the top-level IO\n    val S00_AXI = IO(Flipped(new AXI4Compat(MasterPortParams(\n        base = 0,\n        size = 1L << p(PlatformKey).frontBusAddressNBits,\n        beatBytes = ap.dataBits / 8,\n        idBits = ap.idBits))))\n    // connect it to our diplomacy node\n    AXI4Compat.connectCompatSlave(S00_AXI, port_cast.out(0)._1)\n\n    if (withDMA) {\n        val dma = IO(Flipped(new AXI4Compat(MasterPortParams(\n            base = 0,\n            size = platform.extMem.master.size,\n            beatBytes = dma_cast.get.out(0)._1.r.bits.data.getWidth/8,\n            idBits = 6))))\n        AXI4Compat.connectCompatSlave(dma, dma_cast.get.out(0)._1)\n    }\n\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We use ",(0,i.jsx)(n.code,{children:"AXI4Compat"})," because it provides better naming compared to more Chisel-friendly module types and, as a result,\nmaps to a AXI4 port when you instantiate a ",(0,i.jsx)(n.code,{children:"BeethovenTop"})," module in Vivado. We provide the ",(0,i.jsx)(n.code,{children:"connectCompatSlave"})," to\nconnect these Vivado-friendly ports with Diplomacy-friendly AXI4 ports."]}),"\n",(0,i.jsx)(n.h3,{id:"platform-parameters",children:"Platform Parameters"}),"\n",(0,i.jsx)(n.p,{children:"In addition to these functions, the platform should also declare the following values to facilitate C++ code generation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// these are the default values we use for the AXIFrontBusProtocol\noverride val frontBusBaseAddress: Long = 0\noverride val frontBusAddressNBits: Int = 16\noverride val frontBusAddressMask: Long = 0xFFFF\noverride val frontBusBeatBytes: Int = 4\n"})}),"\n",(0,i.jsx)(n.h3,{id:"alternative-usage-patterns",children:"Alternative Usage Patterns"}),"\n",(0,i.jsx)(n.p,{children:"While we believe this exposure of AXI4 ports will likely be the typical usage-pattern, we have internally used these\nfunctions to test other integrations."}),"\n",(0,i.jsxs)(n.p,{children:["For instance, we tested and verified ",(0,i.jsx)(n.a,{href:"https://github.com/Composer-Team/CHIPKIT/tree/master",children:"ChipKIT"})," integration in this way.\nInstead of AXI4 slave ports for communicating with host, we instantiated an ARM M0 CPU core inside of ",(0,i.jsx)(n.code,{children:"deriveTopIOs"})," and connected\nit to external UART IOs using the ChipKIT IPs. Because the M0 only has a single AHB port for communicating with instruction SRAM,\ndata SRAM, external memory, and Beethoven, we did the following:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Implemented an AHB filter for these domains"}),"\n",(0,i.jsxs)(n.li,{children:["Instantiated the SRAMs inside ",(0,i.jsx)(n.code,{children:"deriveTopIOs"})," and connected these to the AHB filter slave side."]}),"\n",(0,i.jsxs)(n.li,{children:["Convert the AHB Beethoven slave to AXI4 and connect it to a ",(0,i.jsx)(n.code,{children:"FrontBusHub"})," module."]}),"\n",(0,i.jsx)(n.li,{children:"Convert the AHB external memory slave to TileLink and expose to Beethoven as a DMA node."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This integration was one our preliminary efforts towards test-chip integration and, while it was functional, had some issues.\nOur current test-chip integration is currently a work in progress and we will work towards making it usable by others in a\nfuture release. Our emphasis here is that with these interfaces, you can implement a reasonably sophisticated integration."}),"\n",(0,i.jsx)(n.h2,{id:"memory",children:"Memory"}),"\n",(0,i.jsx)(n.p,{children:"Currently, Beethoven exposes AXI4 interfaces to the external memory. While this will be the common case for FPGAs, it may not be\nuniversal. Beethoven instantiates the AXI4 interfaces according to the following parameters as part of your platform declaration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// these are the default values for the AWS F2\noverride val hasDiscreteMemory: Boolean = true\noverride val physicalMemoryBytes: Long = 0x400000000L\noverride val memorySpaceAddressBase: Long = 0x0\noverride val memorySpaceSizeBytes: BigInt = BigInt(1) << 34\noverride val memoryControllerIDBits: Int = 16\noverride val memoryControllerBeatBytes: Int = 64\noverride val memoryNChannels: Int = 1\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"hasDiscreteMemory"})," - this is only used for C++ header generation. It informs the Beethoven runtime whether to use the system\nallocator or to instantiate an allocator for allocating regions in the FPGA's discrete address space."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"physicalMemoryBytes"})," - the size of the ",(0,i.jsx)(n.strong,{children:"physical"})," memory space. This quantity will be generated into the C++ bindings."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"memorySpaceAddressBase"})," - the base address offset for the external memory."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"memorySpaceSizeBytes"})," - the size of the full address space. That is, if you are on an embedded FPGA and the physical address\nspace is much smaller than the virtual address space, you should provide the size of the ",(0,i.jsx)(n.strong,{children:"virtual address space"}),". This\ndetermines the address width of the memory interconnect."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"memoryControllerIDBits"})," - the number of ",(0,i.jsx)(n.strong,{children:"usable"})," ID bits on the external memory interface. Specifying ",(0,i.jsx)(n.code,{children:"0"})," here will still\nelaborate the ",(0,i.jsx)(n.code,{children:"ID"})," field but it will always be driven 0. Otherwise, Beethoven is free to generate memory requests in the\nrange ",(0,i.jsx)(n.code,{children:"[0, 1 << memoryControllerIDBits)"}),". If the number of bits of the field is greater than the number of supported IDs,\nthen set this parameter to support the latter."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"memoryControllerBeatBytes"})," - the data width of the external memory bus."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"memoryNChannels"})," - If you wish to generate multiple different memory channels, increase this parameter. The memory channels\nare ",(0,i.jsx)(n.strong,{children:"discrete"}),", as is required by diplomacy. That is, each memory channel is non-overlapping with the other memory channels.\nThe above parameters apply to a ",(0,i.jsx)(n.strong,{children:"single"})," channel. So if you have two channels, each with 8GB of capacity, you would\nspecify ",(0,i.jsx)(n.code,{children:"memorySpaceSizeBytes=BigInt(1) << 33"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"floorplanning",children:"Floorplanning"}),"\n",(0,i.jsx)(n.p,{children:"Beethoven will attempt to generate device-aware floorplans using the information provided to Beethoven as to the device's topology.\nThe topology presented to Beethoven can correspond directly to the device topology or, for more sophisticated floorplanning, the\ndeveloper could specify a more precise topology on top of a device. For simplicity, we'll first device topologies."}),"\n",(0,i.jsx)(n.p,{children:"The basic interface is shown below for a single-die device. In such cases, there is really nothing more to do and we let our\nbackend tool handle placement by itself."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// default settings - corresponds to a single-die device\ndef placementAffinity: Map[Int, Double] = Map.from(physicalDevices.map { dev => (dev.identifier, 1.0 / physicalDevices.length) })\nval physicalDevices: List[DeviceConfig] = List(DeviceConfig(0, ""))\nval physicalInterfaces: List[PhysicalInterface] = List(PhysicalHostInterface(0), PhysicalMemoryInterface(0, 0))\nval physicalConnectivity: List[(Int, Int)] = List()\n'})}),"\n",(0,i.jsx)(n.p,{children:"However, if we are deploying designs on an AWS F2 FPGA for instance, those FPGAs are constructed from three silicon dies\nconnected with Through-Silicon Vias (TSVs). The delay through the TSVs is high and the number of TSVs are limited so we\nattempt to minimize crossovers by pinning cores onto specified dies and elaborating the interconnects to minimize die crossings."}),"\n",(0,i.jsx)(n.p,{children:"On the AWS F2 instances, we expose three dies using unique integral IDs corresponding to a name that will appear in the floorplanning\nfiles."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'override val physicalDevices: List[DeviceConfig] = List(\n    DeviceConfig(0, "pblock_CL_bot"),\n    DeviceConfig(1, "pblock_CL_mid"),\n    DeviceConfig(2, "pblock_CL_top")\n)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Next, we tell Beethoven which dies contain which physical interfaces. For the AWS F2 instances, the host AXI interface is on\ndie 0 and the memory interface is on die 1. In the future, when we add the support for the many on-chip HBM interfaces, it\nwill be added here to die 0."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"override val physicalInterfaces: List[PhysicalInterface] = List(\n  PhysicalHostInterface(0),\n  PhysicalMemoryInterface(1, 0)\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Next, we tell Beethoven the connectivity between the dies. The connectivity need not be a ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Directed_acyclic_graph",children:"DAG"}),", but it often is."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"override val physicalConnectivity: List[(Int, Int)] = List((0, 1), (1, 2))\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here, we specify that the connectivity is 0 - 1 - 2."}),"\n",(0,i.jsx)(n.h2,{id:"platform-fine-tuning",children:"Platform Fine-Tuning"}),"\n",(0,i.jsx)(n.p,{children:"Finally, Beethoven allows the platform developer to tweak interconnect generation paramters to be more or less aggressive\nbased on their needs."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// only really used in ASIC mode\nval clockRateMHz: Int = 100\n\n// suggest 64 for AWS \nval prefetchSourceMultiplicity: Int = 16\n\nval defaultReadTXConcurrency: Int = 4\nval defaultWriteTXConcurrency: Int = 4\nval xbarMaxDegree = 2\nval maxMemEndpointsPerSystem = 1\nval maxMemEndpointsPerCore = 1\nval interCoreMemReductionLatency = 1\nval interCoreMemBusWidthBytes = 4\n\n/**\n* These default values should typically be fine.\n*/\nval net_intraDeviceXbarLatencyPerLayer = 1\nval net_intraDeviceXbarTopLatency = 1\nval net_fpgaSLRBridgeLatency = 2\n\nval memEndpointsPerDevice = 1\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"prefetchSourceMultiplicity"})," - What is the longest single transaction a reader/writer should emit (beats)? On AWS platforms, the DDR controller recommends 64\nto be able to achieve maximum DDR efficiency. However, this value linearly impacts the amount of buffering that is required inside of\nthe reader/writer."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"defaultReadTXConcurrency"}),"/",(0,i.jsx)(n.code,{children:"defaultWriteTXConcurrency"})," - This parameter determines how many concurrent transactions a reader/writer can have in flight. This\nalso linearly impacts the amount of necessary buffering and the complexity of the some of the logic. This can be set manually per-reader/writer in their\nconfigurations for modules that require especially high throughput on only some interfaces."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"xbarMaxDegree"})," - the maximum input/output degree for any crossbar in our interconnect generation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"maxMemEndpointsPerSystem"})," / ",(0,i.jsx)(n.code,{children:"maxMemEndpointsPerCore"})," / ",(0,i.jsx)(n.code,{children:"memEndpointsPerDevice"})," - memory nodes are reduced in degree before leaving each system and core. These parameters can be\ntweaked to impact the shape of the interconnect."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"interCoreMemReductionLatency"})," / ",(0,i.jsx)(n.code,{children:"interCoreMemBusWidthBytes"})," - these parameters impact inter-core communication latencies."]}),"\n",(0,i.jsx)(n.li,{children:"Intra-Device crossbar latencies - these parameters determine latencies of interconnects on die boundaries."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);