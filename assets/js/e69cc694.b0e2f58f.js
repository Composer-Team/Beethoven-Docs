"use strict";(self.webpackChunkbeethoven_docs=self.webpackChunkbeethoven_docs||[]).push([[7810],{5296:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"type":"mdx","permalink":"/Beethoven-Docs/Beethoven/SW/","source":"@site/src/pages/Beethoven/SW/index.md","title":"Beethoven Software Stack","description":"One of the goals of Beethoven is to provide a uniform deployment and testing process across platforms:","frontMatter":{},"unlisted":false}');var r=t(4848),o=t(8453),s=t(5537),i=t(9329);const l={},c="Beethoven Software Stack",d={},h=[{value:"A Basic Example (cont&#39;d)",id:"a-basic-example-contd",level:2},{value:"Testbench",id:"testbench",level:3},{value:"Run your code",id:"run-your-code",level:3},{value:"Beethoven Library",id:"beethoven-library",level:2},{value:"Communicating with the Accelerator",id:"communicating-with-the-accelerator",level:3},{value:"Allocating Memory",id:"allocating-memory",level:3},{value:"DMA Transfers",id:"dma-transfers",level:3},{value:"Beethoven Runtime",id:"beethoven-runtime",level:2},{value:"Building",id:"building",level:3},{value:"Memory Modeling",id:"memory-modeling",level:3},{value:"Allocator Implementation",id:"allocator-implementation",level:2},{value:"Discrete Device Allocator",id:"discrete-device-allocator",level:3},{value:"Embedded Device Allocator",id:"embedded-device-allocator",level:3}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"beethoven-software-stack",children:"Beethoven Software Stack"})}),"\n",(0,r.jsxs)(n.p,{children:["One of the goals of Beethoven is to provide a uniform deployment and testing process across platforms:\nUsing an accelerator on a Zynq board should work the same as on AWS F2 and in our simulation platform.\n",(0,r.jsx)(n.a,{href:"https://github.com/ucb-bar/chiseltest/tree/main",children:"ChiselTest"})," and Verilog testbenches are excellent\nfor unit-testing your modules, but are cumbersome for large-scale, end-to-end testing on real datasets."]}),"\n",(0,r.jsx)(n.p,{children:"Along with the Beethoven Hardware library, we've published a software integration stack that\nsupports simulation and device backends, allowing you to test the exact same software binary in\nsimulation before you deploy it. Our simulation backend supports multiple simulators: Verilator, and\nsimulators that support VPI (e.g., Icarus Verilog, VCS)."}),"\n",(0,r.jsx)("p",{align:"center",children:(0,r.jsx)("img",{src:"/Beethoven-Docs/img/figs/execution-stack.jpg"})}),"\n",(0,r.jsx)(n.p,{children:"The software stack comprises a userspace library and a device-management runtime.\nThe userspace library provides utilities for allocating accelerator-accessible memory regions and\nroutines for sending Beethoven-compliant command/response messages to the accelerator. The library\nincorporates the hardware-generated C++ linkage into the programming environment, allowing the\nuser to communicate with their accelerator using the same control signals exposed inside their RTL."}),"\n",(0,r.jsxs)(n.p,{children:["We'll start by looking at a simple example that continues from the hardware design we developed in the\nBeethoven Hardware stack section (",(0,r.jsx)(n.a,{href:"/Beethoven/HW",children:"link"}),")."]}),"\n",(0,r.jsx)(n.h2,{id:"a-basic-example-contd",children:"A Basic Example (cont'd)"}),"\n",(0,r.jsxs)(n.p,{children:["Picking up from where we left off with our vector addition core, we had just built our hardware. With\nyour environment properly set up (having set your ",(0,r.jsx)(n.code,{children:"BEETHOVEN_PATH"})," environment variable in your bashrc),\nit should have generated your hardware modules in ",(0,r.jsx)(n.code,{children:"$BEETHOVEN_PATH/build/hw"})," and your C++ linkages\nin ",(0,r.jsx)(n.code,{children:"$BEETHOVEN_PATH/build/beethoven_hardware.h"})," and ",(0,r.jsx)(n.code,{children:"$BEETHOVEN_PATH/build/beethoven_hardware.cc"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"testbench",children:"Testbench"}),"\n",(0,r.jsx)(n.p,{children:"The header should have a stub that looks like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"namespace myVectorAdd {\n        beethoven::response_handle<bool> vector_add(\n            uint16_t core_id,\n            beethoven::remote_ptr vec_a_addr,\n            beethoven::remote_ptr vec_b_addr,\n            beethoven::remote_ptr vec_out_addr,\n            uint32_t vector_length);\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To use our core, let's set up a new CMake project. Your ",(0,r.jsx)(n.code,{children:"CMakeLists.txt"})," will go in the root directory\nof your c++ directory and will look something like this."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cmake",children:"cmake_minimum_required(VERSION 3.30)\nproject(vector_add)\n\nfind_package(beethoven REQUIRED)\nset(CMAKE_CXX_STANDARD 17)\n\nbeethoven_build(vector_add\n    SOURCES main.cpp)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you've installed the Beethoven software library correctly, ",(0,r.jsx)(n.code,{children:"find_package"})," should work correctly.\n",(0,r.jsx)(n.code,{children:"beethoven_build"})," is a function that declares a new target in a similar way to ",(0,r.jsx)(n.code,{children:"add_executable"}),".\nWe'll create a new c++ source file called ",(0,r.jsx)(n.code,{children:"main.cpp"})," and insert the boilerplate:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <iostream>\n#include <beethoven/fpga_handle.h>\n#include <beethoven_hardware.h>\n\nusing namespace beethoven;\nint main() {\n  fpga_handle_t handle;\n  \n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"fpga_handle_t"})," is our way of communicating with our accelerator. Once it's been constructed\nsomewhere in your executable, you'll be able to call on your accelerator. First, let's look at the\narguments to our vector-add unit."]}),"\n",(0,r.jsxs)(n.p,{children:["First, there's ",(0,r.jsx)(n.code,{children:"core_id"}),". If we elaborated a multi-core accelerator, we can use this argument to\nspecify which core we want to execute our vector-add. Next, we have a few ",(0,r.jsx)(n.code,{children:"beethoven::remote_ptr"}),"\narguments for our vectors. When you use an ",(0,r.jsx)(n.code,{children:"Address"})," type in a ",(0,r.jsx)(n.code,{children:"BeethovenIO"}),", it will result in the\nuse of ",(0,r.jsx)(n.code,{children:"beethoven::remote_ptr"})," in the c++ linkage."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"remote_ptr"})," is a smart pointer that we use for making allocations that are accessible from our\naccelerator. It has ",(0,r.jsx)(n.code,{children:"shared_ptr"})," ",(0,r.jsx)(n.a,{href:"https://en.cppreference.com/w/cpp/memory/shared_ptr",children:"semantics"}),",\nso you should not need to free it manually.The use of this\nspecial type is necessary because some accelerators share the same address space with the host\nCPU (ex. Zynq) whereas others have discrete address spaces (ex. AWS F2). We hide the implementation\ndetails for managing these address spaces inside the pointer type."]}),"\n",(0,r.jsxs)(n.p,{children:["To allocate a slice of memory that is accessible from your accelerator, the ",(0,r.jsx)(n.code,{children:"fpga_handle_t"})," exposes\na ",(0,r.jsx)(n.code,{children:"malloc"})," interface that behaves like a typical C ",(0,r.jsx)(n.code,{children:"malloc"})," interfaces. The ",(0,r.jsx)(n.code,{children:"remote_ptr"})," allocates\na slice of memory in the host address space. You can fetch this pointer using ",(0,r.jsx)(n.code,{children:".getHostAddr()"}),",\ninitialize the memory and use it like a normal memory allocation.\nTo transfer the allocation over to the accelerator-accessible space, we use\n",(0,r.jsx)(n.code,{children:"handle.copy_to_fpga()"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"fpga_handle_t handle;\nint size_of_int = 4;\nint n_eles = 32;\nauto vec_a = handle.malloc(size_of_int * n_eles);\nauto vec_b = handle.malloc(size_of_int * n_eles);\nauto vec_out = handle.malloc(size_of_int * n_eles);\n\nauto vec_a_host = (int*)vec_a.getHostAddr();\nauto vec_b_host = (int*)vec_b.getHostAddr();\nfor (int i = 0; i < n_eles; ++i) {\n    vec_a_host[i] = i + 1;\n    vec_b_host[i] = i * 2;\n}\nhandle.copy_to_fpga(vec_a);\nhandle.copy_to_fpga(vec_b);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now, to call our accelerator we use the stub:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"auto resp_handle = myVectorAdd::vector_add(0,\n                                           vec_a,\n                                           vec_b,\n                                           vec_out,\n                                           n_eles);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This returns a response handle. Although your accelerator is now executing, your host CPU can\ncontinue working until you're ready to block and wait for your code to finish. Then, you\ncan copy your results back to host-accessible memory using ",(0,r.jsx)(n.code,{children:"handle.copy_from_fpga(...)"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"auto response = resp_handle.get()\nhandle.copy_from_fpga(vec_out);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you want to check if your code has finished, but not block if it hasn't, then we also offer a ",(0,r.jsx)(n.code,{children:"try_get()"}),".\nThe ",(0,r.jsx)(n.code,{children:"response"})," payload will be the struct specified by your accelerator core ",(0,r.jsx)(n.code,{children:"BeethovenIO"})," if you\nspecified one. If you specified no response acknowledgement, ",(0,r.jsx)(n.code,{children:".get()"})," will throw an error."]}),"\n",(0,r.jsx)(n.h3,{id:"run-your-code",children:"Run your code"}),"\n",(0,r.jsx)(n.p,{children:"Now we have our testbench. To simulate our code, we'll start up the Beethoven Runtime."}),"\n",(0,r.jsxs)(s.A,{children:[(0,r.jsx)(i.A,{value:"a",label:"Simulation (Icarus Verilog)",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/Composer-Team/Beethoven-Runtime\ncd Beethoven-Runtime\nbash setup_dramsim.sh\n# this will build and run the simulator\nmake sim_icarus\n"})})}),(0,r.jsx)(i.A,{value:"b",label:"Simulation (VCS)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/Composer-Team/Beethoven-Runtime\ncd Beethoven-Runtime\nbash setup_dramsim.sh\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DTARGET=sim -DSIMULATOR=vcs\nmake -j\n../scripts/build_vcs.sh\n\n# run the runtime/simulator\n./BeethovenTop\n"})})}),(0,r.jsx)(i.A,{value:"c",label:"Simulation (Verilator)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/Composer-Team/Beethoven-Runtime\ncd Beethoven-Runtime\nbash setup_dramsim.sh\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DTARGET=sim -DSIMULATOR=verilator\nmake -j\n\n# run the runtime/simulator\n./BeethovenRuntime\n"})})}),(0,r.jsx)(i.A,{value:"d",label:"AWS F2",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/Composer-Team/Beethoven-Runtime\ncd Beethoven-Runtime\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DTARGET=fpga -DBACKEND=F2\nmake -j\n\n# run the runtime\nsudo ./BeethovenRuntime\n"})})}),(0,r.jsx)(i.A,{value:"e",label:"Zynq",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/Composer-Team/Beethoven-Runtime\ncd Beethoven-Runtime\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DTARGET=fpga -DBACKEND=Kria\nmake -j\n\n# run the runtime\nsudo ./BeethovenRuntime\n"})})})]}),"\n",(0,r.jsx)(n.p,{children:"Each one of these simulation platforms should provide the same results. We recommend\nusing either VCS or Icarus Verilog for simulation because they support tri-state logic (X, Z).\nWe've also found instances where the Verilator compile time becomes prohibitively long (hours)\nwhereas simulation + running for the others is a matter of a few minutes."}),"\n",(0,r.jsx)(n.p,{children:"Once your simulator is running, compile and run your testbench binary like so."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"# inside your c testbench directory\nmkdir build\ncd build\ncmake ..\nmake -j\n./vector_add\n"})}),"\n",(0,r.jsx)(n.p,{children:"This will execute your accelerator core! Now you can quit the runtime and view the\nwaveform for your execution."}),"\n",(0,r.jsxs)(n.p,{children:["In Verilator, CTRL+C is sufficient. For VCS and Icarus, CTRL+C to exit to the simulation\nshell and run ",(0,r.jsx)(n.code,{children:"finish"}),". This will ensure the waveform is properly flushed."]}),"\n",(0,r.jsx)(n.h2,{id:"beethoven-library",children:"Beethoven Library"}),"\n",(0,r.jsx)(n.p,{children:"The library implements the integration between the user's testbench process and the simulator / FPGA management process.\nThere are two basic interfaces available to the programmer:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Sending commands/receiving responses"}),"\n",(0,r.jsx)(n.li,{children:"Allocating Memory"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"communicating-with-the-accelerator",children:"Communicating with the Accelerator"}),"\n",(0,r.jsxs)(n.p,{children:["We strongly recommend that any communication you have with your accelerator be over the generated C++ stubs from having\ngenerated your hardware. If you've properly set up your environment, you should find them in ",(0,r.jsx)(n.code,{children:"$BEETHOVEN_PATH/build/beethoven_hardware.h"}),".\nWhenever you call your function stub with the parameters specified by the ",(0,r.jsx)(n.code,{children:"BeethovenIO"})," interface from your hardware, it will\nreturn a ",(0,r.jsx)(n.code,{children:"beethoven::response_handle<type_t>"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<typename t>\nclass response_handle {\n    t get();\n    std::optional<t> try_get();\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The response handle can be used to allow asynchronous execution of the host with the accelerator device. Calling\n",(0,r.jsx)(n.code,{children:".get()"})," blocks the host process while waiting for the accelerator response. ",(0,r.jsx)(n.code,{children:".try_get()"})," will query for a response\nfrom the accelerator and will return a None-type if the response is not ready yet."]}),"\n",(0,r.jsx)(n.h3,{id:"allocating-memory",children:"Allocating Memory"}),"\n",(0,r.jsxs)(n.p,{children:["Beethoven exposes a typical ",(0,r.jsx)(n.code,{children:"malloc"})," interface to the user. It should work identically on embedded platforms, discrete platforms,\nand in simulation - the user should not need to change their usage of malloc based on the platform. The malloc interface is a\nmember of ",(0,r.jsx)(n.code,{children:"fpga_handle_t"}),", which facilitates communication with the accelerator, and should be used like so."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"using namespace beethoven;\n\nint main() {\n    fpga_handle_t handle;\n    ...\n    auto alloc = handle.malloc(64);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:".malloc()"})," will not only allocate space in the accelerator address space, but will allocate an associated space in the host\naddress space. The addresses to these spaces are accessible from the return type from malloc: ",(0,r.jsx)(n.code,{children:"remote_ptr"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"remote_ptr"})," is a smart pointer type that will free itself when no valid references to the allocation exist (equivalent to std::shared_ptr).\nThe host address is accessible via ",(0,r.jsx)(n.code,{children:".getHostAddr()"})," and the FPGA address is accessible via ",(0,r.jsx)(n.code,{children:".getFpgaAddr()"}),". Example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"using namespace beethoven;\n\nint main() {\n    fpga_handle_t handle;\n    ...\n    auto alloc = handle.malloc(64);\n\n    void * host_allocation = alloc.getHostAddr();\n    uint64_t fpga_allocation = alloc.getFpgaAddr();\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In practice there is no reason to use ",(0,r.jsx)(n.code,{children:".getFpgaAddr()"})," because when you use the ",(0,r.jsx)(n.code,{children:"Address"})," type inside the declaration of your hardware's\n",(0,r.jsx)(n.code,{children:"BeethovenIO"})," interfaces, it will produce a C++ stub that directly takes in your ",(0,r.jsx)(n.code,{children:"remote_ptr"})," object and extracts the FPGA address for you."]}),"\n",(0,r.jsx)(n.h3,{id:"dma-transfers",children:"DMA Transfers"}),"\n",(0,r.jsxs)(n.p,{children:["To move data between host and accelerator address spaces, use the ",(0,r.jsx)(n.code,{children:"handle.copy_to_fpga"})," and ",(0,r.jsx)(n.code,{children:"handle.copy_from_fpga"})," routines."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"void copy_to_fpga(const remote_ptr &dst);\nvoid copy_from_fpga(const remote_ptr &src);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["These routines deduce from the generated hardware header how to instrument memory DMA between the host and accelerator. These routines are\nonly ",(0,r.jsx)(n.em,{children:"really"})," necessary on platforms with discrete accelerator/host memory spaces, but we think it's a good idea to instrument your code\nwith these routines even if you don't need them to improve code portability across platforms."]}),"\n",(0,r.jsx)(n.h2,{id:"beethoven-runtime",children:"Beethoven Runtime"}),"\n",(0,r.jsxs)(n.p,{children:["When using the runtime over a real FPGA, the runtime manages all communication between host\nprocesses and the device. It is responsible for moving over commands as well as polling the\nFPGA for responses. The rate of this polling is configurable in the source file\n",(0,r.jsx)(n.code,{children:"src/response_poller.cc"})," ",(0,r.jsx)(n.a,{href:"https://github.com/Composer-Team/Beethoven-Runtime/blob/master/src/response_poller.cc",children:"[link]"}),"\nif you wish to increase or decrease the rate. By default, it is set to 10\xb5s."]}),"\n",(0,r.jsx)(n.h3,{id:"building",children:"Building"}),"\n",(0,r.jsxs)(s.A,{children:[(0,r.jsx)(i.A,{value:"a",label:"Simulation (Icarus Verilog)",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/Composer-Team/Beethoven-Runtime\ncd Beethoven-Runtime\nbash setup_dramsim.sh\n# this will build and run the simulator\nmake sim_icarus\n"})})}),(0,r.jsx)(i.A,{value:"b",label:"Simulation (VCS)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/Composer-Team/Beethoven-Runtime\ncd Beethoven-Runtime\nbash setup_dramsim.sh\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DTARGET=sim -DSIMULATOR=vcs\nmake -j\n../scripts/build_vcs.sh\n\n# run the runtime/simulator\n./BeethovenTop\n"})})}),(0,r.jsx)(i.A,{value:"c",label:"Simulation (Verilator)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/Composer-Team/Beethoven-Runtime\ncd Beethoven-Runtime\nbash setup_dramsim.sh\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DTARGET=sim -DSIMULATOR=verilator\nmake -j\n\n# run the runtime/simulator\n./BeethovenRuntime\n"})})}),(0,r.jsx)(i.A,{value:"d",label:"AWS F2",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/Composer-Team/Beethoven-Runtime\ncd Beethoven-Runtime\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DTARGET=fpga -DBACKEND=F2\nmake -j\n\n# run the runtime\nsudo ./BeethovenRuntime\n"})})}),(0,r.jsx)(i.A,{value:"e",label:"Zynq",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/Composer-Team/Beethoven-Runtime\ncd Beethoven-Runtime\nmkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DTARGET=fpga -DBACKEND=Kria\nmake -j\n\n# run the runtime\nsudo ./BeethovenRuntime\n"})})})]}),"\n",(0,r.jsx)(n.h3,{id:"memory-modeling",children:"Memory Modeling"}),"\n",(0,r.jsxs)(n.p,{children:["Beethoven hardware emits memory transactions using the AXI4 protocol. To accurately model DRAM latencies in our simulator\nwe implement a AXI4-DDR controller that models DDR using ",(0,r.jsx)(n.a,{href:"https://github.com/umd-memsys/DRAMsim3/tree/master",children:"DRAMSim3"}),".\nDRAMSim3 allows us to model different memory technologies by simply changing the memory configuration input file.\nBy default we use the ",(0,r.jsx)(n.code,{children:"DDR4_8Gb_x16_3200.ini"})," config that comes with DRAMSim, but you can change the configuration\nby defining the ",(0,r.jsx)(n.code,{children:"DRAMSIM_CONFIG"})," build variable for VPI-based builds or by starting the Verilator-based simulator\nusing ",(0,r.jsx)(n.code,{children:"./BeethovenTop -dramconfig <your_config>"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"allocator-implementation",children:"Allocator Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"discrete-device-allocator",children:"Discrete Device Allocator"}),"\n",(0,r.jsx)(n.p,{children:"When operating on a discrete device, Beethoven provides a thread-safe allocator implementation\nso that separate threads and processes can fully utilize the FPGA's memory space without\nrelying on inter-process communication to synchronize allocations."}),"\n",(0,r.jsx)(n.p,{children:"The allocator maintains allocation state entirely in the runtime process and stores nothing inside\nthe FPGA memory. It is a slab-based allocator with 2MB slabs and a minimum allocation size of 4KB.\nAllocations of less than 4KB will not fault, but will incur external fragmentation."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/Composer-Team/Beethoven-Software/blob/master/include/beethoven/allocator/device_allocator.h",children:"[Implementation]"})}),"\n",(0,r.jsx)(n.h3,{id:"embedded-device-allocator",children:"Embedded Device Allocator"}),"\n",(0,r.jsxs)(n.p,{children:["When the accelerator device shares the address space with the host CPU, the operating system needs\nto know about the allocations that we make. Currently, we don't support virtual addressing on the\nZynq platforms, so we use Linux ",(0,r.jsx)(n.a,{href:"https://www.kernel.org/doc/html/latest/admin-guide/mm/hugetlbpage.html",children:"[hugepages]"}),"\nto make physical memory allocations that are larger than 4KB. When running on a Zynq system,\nBeethoven's ",(0,r.jsx)(n.code,{children:"malloc"})," uses ",(0,r.jsx)(n.code,{children:"mmap"})," to allocate the memory and then obtains the virtual to physical\nmapping from the OS."]}),"\n",(0,r.jsxs)(n.p,{children:["We provide a script ",(0,r.jsx)(n.a,{href:"https://github.com/Composer-Team/Beethoven/blob/main/bin/kria/kria_mm.py",children:"here"})," for\npre-allocating hugepages on Zynq platforms."]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},5537:(e,n,t)=>{t.d(n,{A:()=>_});var a=t(6540),r=t(4164),o=t(5627),s=t(6347),i=t(372),l=t(604),c=t(1861),d=t(8749);function h(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:t}=e;const r=(0,s.W6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l.aZ)(o),(0,a.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(r.location.search);n.set(o,e),r.replace({...r.location,search:n.toString()})}),[o,r])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,o=u(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[c,h]=p({queryString:t,groupId:r}),[b,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,o]=(0,d.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:r}),v=(()=>{const e=c??b;return m({value:e,tabValues:o})?e:null})();(0,i.A)((()=>{v&&l(v)}),[v]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),h(e),g(e)}),[h,g,o]),tabValues:o}}var g=t(9136);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=t(4848);function x(e){let{className:n,block:t,selectedValue:a,selectValue:s,tabValues:i}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.a_)(),d=e=>{const n=e.currentTarget,t=l.indexOf(n),r=i[t].value;r!==a&&(c(n),s(r))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:i.map((e=>{let{value:n,label:t,attributes:o}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>{l.push(e)},onKeyDown:h,onClick:d,...o,className:(0,r.A)("tabs__item",v.tabItem,o?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function y(e){let{lazy:n,children:t,selectedValue:o}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===o));return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==o})))})}function j(e){const n=b(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",v.tabList),children:[(0,f.jsx)(x,{...n,...e}),(0,f.jsx)(y,{...n,...e})]})}function _(e){const n=(0,g.A)();return(0,f.jsx)(j,{...e,children:h(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var a=t(6540);const r={},o=a.createContext(r);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(o.Provider,{value:n},e.children)}},9329:(e,n,t)=>{t.d(n,{A:()=>s});t(6540);var a=t(4164);const r={tabItem:"tabItem_Ymn6"};var o=t(4848);function s(e){let{children:n,hidden:t,className:s}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,s),hidden:t,children:n})}}}]);